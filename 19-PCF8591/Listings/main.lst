C51 COMPILER V9.54   MAIN                                                                  03/14/2025 21:25:09 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          // // #include <reg52.h>
   2          #include <STC15F2K60S2.h>
   3          #include "iic.h"
   4          
   5          //Delay
   6          void Delay(unsigned int t){
   7   1          while(t--);
   8   1      }
   9          //System Init
  10          void Set_HC573(unsigned char channel,unsigned char dat){
  11   1        P2 = (P2 & 0x1f) | (channel << 5);
  12   1        P0 = dat;
  13   1      }
  14          unsigned char LED_State = 0xff;
  15          //SMG
  16          unsigned char SMGCode[] =
  17          {
  18          0xc0, //0
  19          0xf9, //1
  20          0xa4, //2
  21          0xb0, //3
  22          0x99, //4
  23          0x92, //5
  24          0x82, //6
  25          0xf8, //7
  26          0x80, //8
  27          0x90, //9
  28          0x88, //A
  29          0x83, //b
  30          0xc6, //C
  31          0xa1, //d
  32          0x86, //E
  33          0x8e, //F
  34          0xBF, //-
  35          0xff //None
  36          };
  37          void SMG(unsigned char Location,unsigned char num){
  38   1          Set_HC573(6,(0x01 << Location));
  39   1          Set_HC573(7, SMGCode[num]);
  40   1          Delay(500);
  41   1        Set_HC573(7,0xff);
  42   1      }
  43          void SMGDot(unsigned char Location,unsigned char num){
  44   1          Set_HC573(6,(0x01 << Location));
  45   1          Set_HC573(7, SMGCode[num]-0x80);
  46   1          Delay(500);
  47   1        Set_HC573(7,0xff);
  48   1      }
  49          
  50          unsigned char dat[8];
  51          
  52          void PCF8591_DAC(unsigned char *dat,unsigned char len){
  53   1        unsigned char i;
  54   1        I2CStart();
C51 COMPILER V9.54   MAIN                                                                  03/14/2025 21:25:09 PAGE 2   

  55   1        I2CSendByte(0x90);
  56   1        I2CWaitAck();
  57   1        I2CSendByte(0x44);    //0100 0100
  58   1        I2CWaitAck();
  59   1        for(i=0;i<len;i++){
  60   2          I2CSendByte(dat[i]);
  61   2          I2CWaitAck();
  62   2        }
  63   1        I2CStop();
  64   1      }
  65          
  66          void PCF8591_ADC_Init(unsigned char channel) {
  67   1          I2CStart();
  68   1          I2CSendByte(0x90);  // PCF8591地址 + 写位(0)
  69   1          I2CWaitAck();
  70   1          I2CSendByte(0x40 | channel);  // 控制字节：选择通道(0-3)，模拟输入模式
  71   1          I2CWaitAck();
  72   1          I2CStop();
  73   1          
  74   1          // 等待转换完成
  75   1          Delay(10);
  76   1      }
  77          
  78          unsigned char PCF8591_ReadADC(unsigned char channel) {
  79   1          unsigned char val;
  80   1          
  81   1          // 设置ADC通道
  82   1          PCF8591_ADC_Init(channel);
  83   1          
  84   1          // 读取ADC值
  85   1          I2CStart();
  86   1          I2CSendByte(0x91);  // PCF8591地址 + 读位(1)
  87   1          I2CWaitAck();
  88   1          
  89   1          // 丢弃第一个字节(上次转换结果)
  90   1          val = I2CReceiveByte();
  91   1          I2CSendAck(0);  // 继续读取
  92   1          
  93   1          // 读取有效值
  94   1          val = I2CReceiveByte();
  95   1          I2CSendAck(1);  // 发送NACK结束读取
  96   1          
  97   1          I2CStop();
  98   1          return val;
  99   1      }
 100          
 101          void PCF8591_ReadMultiChannel(unsigned char *dat, unsigned char channels) {
 102   1          unsigned char i;
 103   1          
 104   1          // 读取多个通道
 105   1          for(i = 0; i < channels && i < 4; i++) {
 106   2              dat[i] = PCF8591_ReadADC(i);
 107   2              Delay(5);  // 短暂延时确保转换完成
 108   2          }
 109   1      }
 110          void PCF8591_ADC(unsigned char *dat,unsigned char len){
 111   1        unsigned char i;
 112   1        I2CStart();
 113   1        I2CSendByte(0x91);
 114   1        I2CWaitAck();
 115   1        for(i=0;i<len-1;i++){
 116   2          dat[i]=I2CReceiveByte();
C51 COMPILER V9.54   MAIN                                                                  03/14/2025 21:25:09 PAGE 3   

 117   2          I2CSendAck(0);
 118   2        }
 119   1        dat[len-1]=I2CReceiveByte();
 120   1        I2CSendAck(1);
 121   1        I2CStop();
 122   1      }
 123          
 124          void DisplayNum(){
 125   1        SMG(0,dat[0]/10);
 126   1        SMG(1,dat[0]%10);
 127   1        SMG(2,16);
 128   1        SMG(3,dat[1]/10);
 129   1        SMG(4,dat[1]%10);
 130   1        SMG(5,16);
 131   1        SMG(6,dat[2]/10);
 132   1        SMG(7,dat[2]%10);
 133   1      }
 134          void InitSystem(){
 135   1        Set_HC573(0,0x00);
 136   1        Set_HC573(5,0x00);  //Disable Buzzer
 137   1        Set_HC573(4,0xff);  //Disable LED
 138   1        Set_HC573(6,0xff);
 139   1        Set_HC573(7,0xff);  //Disable SMG
 140   1      }
 141          
 142          // void main()
 143          // {
 144          //     InitSystem();
 145          //  Delay(100);
 146          //     while(1)
 147          //     {
 148          //    PCF8591_ADC(dat,8);
 149          //    DisplayNum();
 150          //     }
 151          // }
 152          void main() {
 153   1          unsigned char adc_values[4];
 154   1          
 155   1          InitSystem();
 156   1          Delay(100);
 157   1          
 158   1          while(1) {
 159   2              // 读取所有通道
 160   2          adc_values[0]=PCF8591_ReadADC(2);
 161   2              // PCF8591_ReadMultiChannel(adc_values, 0);
 162   2              
 163   2              // 显示光敏电阻值(AIN0)
 164   2              SMG(0, 10);  // 'A'
 165   2              SMG(1, 0);   // '0'
 166   2              SMG(2, 17);  // 空白
 167   2              SMG(3, adc_values[0]/100);      // 百位
 168   2              SMG(4, (adc_values[0]%100)/10); // 十位
 169   2              SMG(5, adc_values[0]%10);       // 个位
 170   2              // Delay(50000);
 171   2              
 172   2              // // 显示热敏电阻值(AIN1)
 173   2              // SMG(0, 10);  // 'A'
 174   2              // SMG(1, 1);   // '1'
 175   2              // SMG(2, 17);  // 空白
 176   2              // SMG(3, adc_values[1]/100);      // 百位
 177   2              // SMG(4, (adc_values[1]%100)/10); // 十位
 178   2              // SMG(5, adc_values[1]%10);       // 个位
C51 COMPILER V9.54   MAIN                                                                  03/14/2025 21:25:09 PAGE 4   

 179   2              // Delay(50000);
 180   2              
 181   2              // // 显示电位器值(AIN2)
 182   2              // SMG(0, 10);  // 'A'
 183   2              // SMG(1, 2);   // '2'
 184   2              // SMG(2, 17);  // 空白
 185   2              // SMG(3, adc_values[2]/100);      // 百位
 186   2              // SMG(4, (adc_values[2]%100)/10); // 十位
 187   2              // SMG(5, adc_values[2]%10);       // 个位
 188   2              // Delay(50000);
 189   2          }
 190   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    594    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     27      21
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
